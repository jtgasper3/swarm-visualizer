<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Docker Swarm Monitor</title>
  <!-- Add Vue 3 CDN -->
  <script src="https://unpkg.com/vue@3"></script>
  <!-- Add Vuetify 3 CDN -->
  <script src="https://cdn.jsdelivr.net/npm/vuetify@3.7.11/dist/vuetify.min.js"></script>
  <!-- Add Vuetify CSS -->
  <link href="https://cdn.jsdelivr.net/npm/vuetify@3.7.11/dist/vuetify.min.css" rel="stylesheet">
  <!-- Add Material Design Icons -->
  <link href="https://cdn.jsdelivr.net/npm/@mdi/font/css/materialdesignicons.min.css" rel="stylesheet">
  <!-- Load the Nodes component JavaScript -->
  <script src="nodes.js" type="module"></script>
</head>

<body>
  <div id="app">
    <v-app>
      <v-main>
        <v-container class="pa-md-12 mx-auto" fluid>
          <h2 v-if="clusterName" class="text-h4 font-weight-bold mb-4 text-center">{{ clusterName }}</h2>
          <v-row>
            <v-col v-for="node in nodes" :key="node.id" class="d-flex" cols="12" lg="3" sm="6">
              <v-card border color="grey-lighten-4" flat rounded="lg">
                <v-card-title>
                  <v-badge :color="nodeStatus(node.status)" dot inline floating :title="node.status"></v-badge> {{
                  node.hostname }}
                </v-card-title>
                <v-card-subtitle>id: {{ node.id }}</v-card-subtitle>
                <v-card-text class="mt-n2">
                  <v-chip color="primary" class="ma-1 pa-1" label size="x-medium">{{ node.role }}</v-chip>
                  <v-chip color="primary" class="ma-1 pa-1" label size="x-medium">{{ node.platformArchitecture
                    }}</v-chip>
                  <v-spacer />
                  Memory: {{ formatBytes(node.memoryBytes) }}
                </v-card-text>

                <v-card-text class="mt-n4">
                  <v-card v-for="task in node.tasks" :key="task.id" border class="d-flex flex-column mb-2" flat
                    rounded="lg">
                    <v-card-title v-if="task.service">
                      <v-badge :color="taskStatus(task.state)" dot inline floating :title="task.state"></v-badge>
                      {{ task.service.name }}
                    </v-card-title>
                    <v-card-subtitle>
                      id: {{ task.id }}
                    </v-card-subtitle>
                    <v-card-text v-if="task.service" class="mt-n3">
                      <v-chip color="primary" class="ma-1 pa-1" label size="x-medium">{{ task.service.mode }}</v-chip>
                      <v-spacer />
                      <span class="text-medium flex-1-1-100">
                        Image: {{ task.service.image.split('@')[0] }}
                      </span>
                      <v-spacer />
                      <span class="text-small-emphasis">
                        Created: {{ date.format(task.createdAt, 'keyboardDateTime12h') }}
                      </span>
                    </v-card-text>
                    <!-- <v-card-actions>
                      <v-spacer />
          
                      <v-btn class="text-none" color="primary" text="Get Started" />
                    </v-card-actions> -->
                  </v-card>
                </v-card-text>
              </v-card>
            </v-col>
          </v-row>
        </v-container>
      </v-main>
    </v-app>
  </div>

  <script type="module">
    import Nodes from './nodes.js';

    const { createApp } = Vue;
    const { createVuetify, useDate } = Vuetify;

    const vuetify = createVuetify();

    createApp({
      data() {
        return {
          clusterName: "Loading...",
          date: useDate(),
          services: [],
          nodes: [],

          // ws connection
          ws: null,
          reconnectAttempts: 0,
          maxReconnectInterval: 30000 // 30 seconds
        };
      },
      computed: {

      },
      mounted() {
        this.connectWebSocket();
      },
      methods: {
        connectWebSocket() {
          this.ws = new WebSocket('ws://' + window.location.host + window.location.pathname + 'ws');

          this.ws.onopen = () => {
            console.log('WebSocket connection established');
            this.reconnectAttempts = 0;
          };

          this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            console.log(data)
            this.clusterName = data.clusterName;
            this.services = data.services;
            this.nodes = data.nodes.map((node) => {
              if (data.tasks) {
                node.tasks = data.tasks
                  .filter(task => task.nodeID === node.ID)
                  .map((task) => {
                    task.service = this.services.find((service) => task.serviceId === service.id);
                    return task;
                  });
              } 
              // else {
              //   node.tasks = [{name: "Unknown", service: {name: "Unknown"}}]
              // }

              return node;
            });
            
          };

          this.ws.onclose = () => {
            console.log('WebSocket connection closed');
            this.reconnectWebSocket();
          };

          this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
          };
        },
        reconnectWebSocket() {
          let reconnectInterval = Math.min(1000 * Math.pow(2, this.reconnectAttempts), this.maxReconnectInterval);

          setTimeout(() => {
            console.log(`Reconnecting in ${reconnectInterval / 1000} seconds...`);
            this.connectWebSocket();
          }, reconnectInterval);

          this.reconnectAttempts++;
        },
        formatBytes(bytes) {
          const units = ['B', 'KB', 'MB', 'GB', 'TB'];
          let unitIndex = 0;

          while (bytes >= 1024 && unitIndex < units.length - 1) {
            bytes /= 1024;
            unitIndex++;
          }

          return `${bytes.toFixed(2)} ${units[unitIndex]}`;
        },
        nodeStatus(status) {
          switch (status) {
            case 'ready': return 'success'; break
            default: return 'error'; break
          }
        },
        taskStatus(status) {
          switch (status) {
            case 'running': return 'success'; break
            default: return 'error'; break
          }
        },
      },
      beforeDestroy() {
        if (this.ws) {
          this.ws.close();
        }
      }
    }).use(vuetify).mount('#app');
  </script>
</body>

</html>